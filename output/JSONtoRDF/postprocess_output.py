# Script to post-process the raw RDF-XML Output generated by LLM.
# Step 1: Every string that is invalid xml i.e. outside of transaction logic gets commented out, because it resembles additional comments from the LLM.
# Step 2: Inserts RDF header around the entire data, also adds 2 generic elements (<gams:isMemberofCollection> and <gams:isPartOf>)
# Step 3: Fixes invalid strings that are common bugs in the LLM output. Can be extended/adapted as needed.
# Step 4: Cleaning up the RDF by splitting multinode_properties into the valid RDF (f.e. 1 bk:transfers with 2 children bk:Money gets converted to 2 bk:transfers with 1 child bk:Money for each)

# Author: Max Vogeltanz, University of Graz, 2025

from lxml import etree as ET
import os
import re

# ──────────────── Paths ─────────────────
base_dir = os.path.dirname(os.path.abspath(__file__))
rdf_input_path = os.path.join(base_dir, "CLAUDE/raw/result_344_claude-sonnet-4-5.xml") # adapt as needed
rdf_output_path = os.path.join(base_dir, "CLAUDE/postprocessed/result_344_claude-sonnet-4-5.xml") # adapt as needed

# ──────────────── Step 1: Comment invalid lines ─────────────────
def comment_invalid_text(input_path, output_path):
    with open(input_path, "r", encoding="utf-8") as f:
        content = f.read()

    commented_lines = []
    for line in content.splitlines():
        stripped = line.strip()
        if stripped and not stripped.startswith("<"):
            commented_lines.append(f"<!-- {stripped} -->")
        else:
            commented_lines.append(line)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(commented_lines))

comment_invalid_text(rdf_input_path, rdf_output_path)

# ──────────────── Step 2: Insert RDF header and footer, add "<gams:isMemberofCollection> and <gams:isPartOf>" ─────────────────
rdf_header = """<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF xmlns:bk="https://gams.uni-graz.at/o:depcha.bookkeeping#"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:depcha="https://gams.uni-graz.at/o:depcha.ontology#"
    xmlns:functx="http://www.functx.com"
    xmlns:gams="https://gams.uni-graz.at/o:gams-ontology#"
    xmlns:gn="http://www.geonames.org/ontology#"
    xmlns:huc="https://gams.uni-graz.at/o:depcha.huc-ontology#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:schema="https://schema.org/"
    xmlns:skos="http://www.w3.org/2004/02/skos/core#"
    xmlns:t="http://www.tei-c.org/ns/1.0"
    xmlns:time="http://www.w3.org/2006/time#"
    xmlns:void="http://rdfs.org/ns/void#">
"""

def insert_rdf_header_footer(path):
    with open(path, "r", encoding="utf-8") as f:
        body = f.read().strip()
    # Only insert if not already present
    if not body.startswith("<?xml") and "<rdf:RDF" not in body:
        wrapped = rdf_header + "\n" + body + "\n</rdf:RDF>\n"
        with open(path, "w", encoding="utf-8") as f:
            f.write(wrapped)
        print("✅ RDF header and footer inserted.")
    else:
        print("ℹ️ RDF header/footer already present — skipping.")

insert_rdf_header_footer(rdf_output_path)

# add "<gams:isMemberOfCollection rdf:resource="https://gams.uni-graz.at/context:depcha.aldersbach"/>" below bk:Transaction
def add_collection_membership(input_path, output_path):
    parser = ET.XMLParser(remove_blank_text=False)
    tree = ET.parse(input_path, parser)
    root = tree.getroot()

    BK_NS = "https://gams.uni-graz.at/o:depcha.bookkeeping#"
    GAMS_NS = "https://gams.uni-graz.at/o:gams-ontology#"
    RDF_NS = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"

    nsmap = {
        "bk": BK_NS,
        "gams": GAMS_NS,
        "rdf": RDF_NS,
    }

    # Collect all relevant RDF entities
    transactions = root.xpath("//bk:Transaction", namespaces=nsmap)
    totaltransactions = root.xpath("//bk:TotalTransaction", namespaces=nsmap)
    notas = root.xpath("//bk:Nota", namespaces=nsmap)

    targets = transactions + totaltransactions + notas

    added = 0

    for tx in targets:

        # Get base URI from rdf:about
        about = tx.get(f"{{{RDF_NS}}}about")
        if about and "#" in about:
            base_uri = about.split("#")[0]
        else:
            # Skip entities without rdf:about (should not happen, but safe)
            continue

        # 1. Insert gams:isMemberOfCollection (if missing)
        existing_member = tx.xpath("./gams:isMemberOfCollection", namespaces=nsmap)
        if not existing_member:
            member_el = ET.Element(f"{{{GAMS_NS}}}isMemberOfCollection")
            member_el.set(f"{{{RDF_NS}}}resource",
                          "https://gams.uni-graz.at/context:depcha.aldersbach")
            tx.insert(0, member_el)

        # 2. Insert gams:isPartOf (if missing)
        existing_part = tx.xpath("./gams:isPartOf", namespaces=nsmap)
        if not existing_part:
            part_el = ET.Element(f"{{{GAMS_NS}}}isPartOf")
            part_el.set(f"{{{RDF_NS}}}resource", base_uri)
            # Insert AFTER isMemberOfCollection = index 1
            tx.insert(1, part_el)

        added += 1

    tree.write(output_path, encoding="utf-8", xml_declaration=True, pretty_print=True)
    print(
        f"✅ Added gams:isMemberOfCollection + gams:isPartOf to {added} elements (in: Transaction/TotalTransaction/Nota). Uri = {base_uri}"
    )

add_collection_membership(rdf_output_path, rdf_output_path)


# ──────────────── Step 3: Fix invalid strings ─────────────────
with open(rdf_output_path, "r", encoding="utf-8") as f:
    content = f.read()

content = content.replace('<!-- --- -->', '')
#content = re.sub(r'<bk:status>.*?</bk:status>', '', content) # Removing bk:status
content = content.replace('``````xml', '').replace('```xml', '') # remove typical invalid output
content = content.replace('```', '')
content = content.replace('```rdf', '') # remove typical invalid output
content = content.replace(' xmlns:bk="https://gams.uni-graz.at/context:depcha.aldersbach#"', '') # remove typical invalid output
content = content.replace('bk:Transaction xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"', 'bk:Transaction') # remove typical invalid output
content = content.replace('<!--  -->', '') # remove empty comments


# optional deletion of rdf:about attributes
#content = re.sub(r'(<bk:Transaction )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Nota )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:TotalTransaction )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:SubTotalTransaction )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Transfer )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Money )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Commodity )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Service )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Right )rdf:about=".*?"(>)', r'\1\2', content)
#content = re.sub(r'(<bk:Debt )rdf:about=".*?"(>)', r'\1\2', content)

content = re.sub(r'\n\s*\n', '\n', content) # Remove empty lines (including lines with only spaces or tabs)
content = re.sub(r'\bst[üu]ck\b', 'piece', content, flags=re.IGNORECASE) # Stück, Stueck, etc. wird zu piece

with open(rdf_output_path, "w", encoding="utf-8") as f:
    f.write(content)

# remove all code comments
def remove_all_comments(input_path):
    parser = ET.XMLParser(remove_blank_text=False, remove_comments=True)
    tree = ET.parse(input_path, parser)
    tree.write(input_path, encoding="utf-8", xml_declaration=True, pretty_print=True)
    print("✅ All comments removed.")
remove_all_comments(rdf_output_path)


print("✅ Commenting and cleanup complete.")


# ──────────────── Step 4: RDF Cleaner ─────────────────
BK_NS = "https://gams.uni-graz.at/o:depcha.bookkeeping#"

def split_multinode_properties_generic(tree: ET._ElementTree):
    changed = False
    fixed_count = 0
    root = tree.getroot()

    # List of parent tags to process
    parent_tags = ["transfers", "ows", "consistsOf"]  # Add more if needed
    # List of child element types to check for multinode properties
    child_types = ["Money", "Commodity", "Service", "Right", "Debt"]  # Add more if needed

    for tag_name in parent_tags:
        xpath_expr = f"//bk:{tag_name}"
        for prop in root.xpath(xpath_expr, namespaces={"bk": BK_NS}):
            # Keep only element children and skip comments/PIs/etc.
            element_children = [c for c in prop if isinstance(getattr(c, "tag", None), str)]
            # Check for any child type in the list
            for child_type in child_types:
                children = [c for c in element_children if ET.QName(c).localname == child_type]
                if len(children) <= 1:
                    continue
                parent = prop.getparent()
                if parent is None:
                    continue
                attrib_copy = dict(prop.attrib)
                idx = parent.index(prop)
                # Remove original property and reinsert split ones
                parent.remove(prop)
                for offset, child in enumerate(children):
                    new_prop = ET.Element(prop.tag, attrib=attrib_copy, nsmap=prop.nsmap)
                    new_prop.append(child)
                    parent.insert(idx + offset, new_prop)
                changed = True
                fixed_count += 1
                break  # Only split once per parent tag

    return changed, fixed_count


def sanitize_rdfxml(input_path, output_path):
    parser = ET.XMLParser(remove_blank_text=False, resolve_entities=False)
    tree = ET.parse(input_path, parser)
    changed, fixed_count = split_multinode_properties_generic(tree)
    tree.write(output_path, encoding="utf-8", xml_declaration=True, pretty_print=True)
    if changed:
        print(f"✅ Sanitized RDF/XML written: {output_path} ({fixed_count} fixes applied)")
    else:
        print(f"✅ RDF/XML sanitized (no fixes needed): {output_path}")

sanitize_rdfxml(rdf_output_path, rdf_output_path)
